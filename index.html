<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#22c55e">
    <title>Bo Jackson Card Scanner</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --primary: #22c55e;
            --primary-dark: #16a34a;
            --secondary: #3b82f6;
            --danger: #ef4444;
            --warning: #f59e0b;
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-400: #9ca3af;
            --gray-600: #6b7280;
            --gray-900: #111827;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: var(--gray-50);
            padding: 12px;
            -webkit-tap-highlight-color: transparent;
            overflow-x: hidden;
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .header {
            text-align: center;
            margin-bottom: 16px;
            background: white;
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        h1 { 
            font-size: 22px; 
            color: var(--gray-900); 
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .subtitle {
            font-size: 13px;
            color: var(--gray-600);
        }
        
        .status-bar {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--gray-200);
            transition: all 0.3s;
        }
        
        .status-dot.ready {
            background: var(--primary);
            box-shadow: 0 0 8px rgba(34, 197, 94, 0.5);
        }
        
        .status-dot.loading {
            background: var(--warning);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-label {
            font-size: 11px;
            color: var(--gray-600);
            text-align: center;
            margin-top: 4px;
        }
        
        .api-section {
            margin-bottom: 16px;
            overflow: hidden;
            transition: all 0.3s;
        }
        
        .api-toggle {
            background: var(--gray-100);
            border: 1px solid var(--gray-200);
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }
        
        .api-toggle:active {
            transform: scale(0.98);
        }
        
        .api-toggle.has-key {
            background: #dcfce7;
            border-color: var(--primary);
        }
        
        .api-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: white;
            border-radius: 0 0 8px 8px;
        }
        
        .api-content.expanded {
            max-height: 300px;
            border: 1px solid var(--gray-200);
            border-top: none;
            padding: 12px;
        }
        
        .api-input-group {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        
        .api-input-group input {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--gray-200);
            border-radius: 6px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
        }
        
        .api-input-group button {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .btn-save {
            background: var(--primary);
            color: white;
        }
        
        .btn-save:active {
            background: var(--primary-dark);
            transform: scale(0.95);
        }
        
        .btn-clear {
            background: var(--gray-200);
            color: var(--gray-600);
        }
        
        .upload-area {
            border: 2px dashed var(--primary);
            border-radius: 12px;
            padding: 32px 20px;
            text-align: center;
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            cursor: pointer;
            margin-bottom: 16px;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        
        .upload-area:active {
            transform: scale(0.98);
        }
        
        .upload-area.processing {
            border-color: var(--secondary);
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
        }
        
        .upload-area.processing::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.2), transparent);
            animation: shimmer 1.5s infinite;
        }
        
        @keyframes shimmer {
            to { left: 100%; }
        }
        
        input[type="file"] { display: none; }
        
        .upload-icon { 
            font-size: 40px; 
            margin-bottom: 8px;
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        .upload-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--gray-900);
            margin-bottom: 4px;
        }
        
        .upload-subtitle {
            font-size: 13px;
            color: var(--gray-600);
        }
        
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 16px;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: 700;
            line-height: 1;
        }
        
        .stat-label {
            font-size: 10px;
            color: var(--gray-600);
            margin-top: 2px;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .loading-overlay.active {
            display: flex;
        }
        
        .loading-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            text-align: center;
            min-width: 200px;
            animation: slideUp 0.3s ease;
        }
        
        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--gray-200);
            border-top-color: var(--primary);
            border-radius: 50%;
            margin: 0 auto 12px;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 14px;
            color: var(--gray-600);
            margin-bottom: 8px;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--gray-200);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), #10b981);
            transition: width 0.3s ease;
        }
        
        .action-bar {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            justify-content: flex-end;
        }
        
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn:active {
            transform: scale(0.95);
        }
        
        .btn-primary { background: var(--primary); color: white; }
        .btn-danger { background: var(--danger); color: white; }
        .btn-secondary { background: var(--gray-200); color: var(--gray-600); }
        
        .cards-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }
        
        @media (min-width: 640px) {
            .cards-grid { grid-template-columns: repeat(2, 1fr); }
        }
        
        @media (min-width: 1024px) {
            .cards-grid { grid-template-columns: repeat(3, 1fr); }
        }
        
        .card {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            transition: all 0.2s;
        }
        
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.12);
        }
        
        .card-image {
            width: 100%;
            height: 160px;
            object-fit: cover;
            background: var(--gray-100);
        }
        
        .card-body {
            padding: 10px;
        }
        
        .card-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 700;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        
        .badge-free { background: #e0e7ff; color: #3730a3; }
        .badge-paid { background: #dcfce7; color: #166534; }
        
        .card-fields {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 8px;
        }
        
        .field {
            position: relative;
        }
        
        .field-label {
            font-size: 9px;
            color: var(--gray-600);
            font-weight: 600;
            margin-bottom: 2px;
            text-transform: uppercase;
        }
        
        .field-input {
            width: 100%;
            padding: 6px;
            border: 1px solid var(--gray-200);
            border-radius: 4px;
            font-size: 12px;
            font-family: inherit;
            transition: all 0.2s;
        }
        
        .field-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.1);
        }
        
        .field-input.auto-filled {
            background: #f0fdf4;
            border-color: var(--primary);
        }
        
        .btn-remove {
            width: 100%;
            padding: 6px;
            background: var(--gray-100);
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            color: var(--gray-600);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-remove:active {
            background: var(--gray-200);
            transform: scale(0.95);
        }
        
        .empty-state {
            text-align: center;
            padding: 48px 20px;
            color: var(--gray-400);
        }
        
        .hidden { display: none; }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 999;
            padding: 20px;
        }
        
        .modal.active { display: flex; }
        
        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 20px;
            max-width: 400px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideUp 0.3s ease;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .modal-title {
            font-size: 18px;
            font-weight: 700;
        }
        
        .modal-close {
            font-size: 28px;
            color: var(--gray-400);
            cursor: pointer;
            line-height: 1;
            transition: color 0.2s;
        }
        
        .modal-close:hover {
            color: var(--gray-600);
        }
        
        .setting-group {
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--gray-200);
        }
        
        .setting-group:last-child {
            border-bottom: none;
        }
        
        .setting-label {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .setting-desc {
            font-size: 11px;
            color: var(--gray-600);
            margin-top: 4px;
        }
        
        .toggle {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }
        
        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--gray-200);
            transition: 0.3s;
            border-radius: 24px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background: white;
            transition: 0.3s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background: var(--primary);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }
        
        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--gray-200);
            border-radius: 6px;
            font-size: 13px;
        }
        
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1001;
        }
        
        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .toast-icon {
            font-size: 20px;
        }
        
        .toast-message {
            font-size: 13px;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <span>üé¥</span>
                <span>Card Scanner</span>
            </h1>
            <div class="subtitle">Smart OCR + AI Detection</div>
            
            <div class="status-bar">
                <div>
                    <div class="status-dot" id="statusDb"></div>
                    <div class="status-label">DB</div>
                </div>
                <div>
                    <div class="status-dot" id="statusOcr"></div>
                    <div class="status-label">OCR</div>
                </div>
                <div>
                    <div class="status-dot" id="statusCv"></div>
                    <div class="status-label">CV</div>
                </div>
            </div>
        </div>

        <div class="api-section">
            <div class="api-toggle" id="apiToggle" onclick="toggleApiSection()">
                <div>
                    <span id="apiToggleText">üîë API Key</span>
                    <span style="font-size: 11px; color: var(--gray-600); margin-left: 8px;">(Optional)</span>
                </div>
                <span id="apiToggleIcon">‚ñº</span>
            </div>
            <div class="api-content" id="apiContent">
                <div style="font-size: 12px; color: var(--gray-600); margin-bottom: 8px;">
                    Get at <a href="https://console.anthropic.com" target="_blank" style="color: var(--primary);">console.anthropic.com</a>
                </div>
                <div class="api-input-group">
                    <input type="password" id="apiKeyInput" placeholder="sk-ant-api03-...">
                    <button class="btn-save" onclick="saveApiKey()">Save</button>
                    <button class="btn-clear" onclick="clearApiKey()">‚úï</button>
                </div>
            </div>
        </div>

        <div class="stats-bar hidden" id="statsBar">
            <div class="stat">
                <div class="stat-value" style="color: var(--primary);" id="statFree">0</div>
                <div class="stat-label">FREE</div>
            </div>
            <div class="stat">
                <div class="stat-value" style="color: var(--secondary);" id="statPaid">0</div>
                <div class="stat-label">PAID</div>
            </div>
            <div class="stat">
                <div class="stat-value" style="color: var(--warning);" id="statCost">$0</div>
                <div class="stat-label">COST</div>
            </div>
            <div class="stat">
                <div class="stat-value" style="color: #8b5cf6;" id="statRate">0%</div>
                <div class="stat-label">FREE RATE</div>
            </div>
        </div>

        <div class="upload-area" id="uploadArea">
            <input type="file" id="fileInput" multiple accept="image/*" capture="environment">
            <div class="upload-icon">üì∏</div>
            <div class="upload-title">Tap to Scan</div>
            <div class="upload-subtitle">Auto-crop & smart detection</div>
        </div>

        <div class="action-bar hidden" id="actionBar">
            <button class="btn btn-secondary" onclick="openSettings()">‚öôÔ∏è</button>
            <button class="btn btn-danger" onclick="clearAll()">üóëÔ∏è</button>
            <button class="btn btn-primary" onclick="exportCSV()">
                <span>üíæ</span>
                <span id="exportCount">0</span>
            </button>
        </div>

        <div class="cards-grid" id="cardsGrid"></div>

        <div class="empty-state" id="emptyState">
            <div style="font-size: 48px; margin-bottom: 12px;">üì∑</div>
            <div style="font-size: 14px; font-weight: 600; color: var(--gray-600);">No cards yet</div>
            <div style="font-size: 12px; color: var(--gray-400); margin-top: 4px;">Tap above to start</div>
        </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-card">
            <div class="spinner"></div>
            <div class="loading-text" id="loadingText">Processing...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
    </div>

    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Settings</div>
                <div class="modal-close" onclick="closeSettings()">√ó</div>
            </div>
            
            <div class="setting-group">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div class="setting-label">Auto Detection</div>
                        <div class="setting-desc">Crop card automatically</div>
                    </div>
                    <label class="toggle">
                        <input type="checkbox" id="toggleAutoDetect" checked onchange="updateSetting('autoDetect', this.checked)">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="setting-group">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div class="setting-label">Perspective Fix</div>
                        <div class="setting-desc">Straighten angled photos</div>
                    </div>
                    <label class="toggle">
                        <input type="checkbox" id="togglePerspective" checked onchange="updateSetting('perspective', this.checked)">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="setting-group">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div class="setting-label">Region OCR</div>
                        <div class="setting-desc">Faster, targeted scanning</div>
                    </div>
                    <label class="toggle">
                        <input type="checkbox" id="toggleRegionOcr" checked onchange="updateSetting('regionOcr', this.checked)">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="setting-group">
                <div class="setting-label">Image Quality</div>
                <select id="selectQuality" onchange="updateSetting('quality', this.value)">
                    <option value="0.5">Low (Fastest)</option>
                    <option value="0.7" selected>Medium</option>
                    <option value="0.9">High (Best)</option>
                </select>
            </div>
            
            <div class="setting-group">
                <div class="setting-label">OCR Threshold: <span id="thresholdValue">60</span>%</div>
                <input type="range" id="rangeThreshold" min="20" max="80" value="60" 
                       oninput="document.getElementById('thresholdValue').textContent = this.value; updateSetting('threshold', this.value)">
                <div class="setting-desc">Lower = more AI fallbacks (try 20% for free scans)</div>
            </div>
            
            <button class="btn btn-secondary" style="width: 100%;" onclick="resetSettings()">
                Reset Defaults
            </button>
        </div>
    </div>

    <div class="toast" id="toast">
        <span class="toast-icon" id="toastIcon">‚úì</span>
        <span class="toast-message" id="toastMessage"></span>
    </div>

    <script>
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js';
        script.async = true;
        document.head.appendChild(script);
    </script>

    <script>
        let cards = [];
        let apiKey = localStorage.getItem('api_key') || '';
        let stats = { scanned: 0, free: 0, cost: 0 };
        let database = [];
        let tesseractWorker = null;
        let ready = { db: false, ocr: false, cv: false };
        
        const config = {
            autoDetect: localStorage.getItem('autoDetect') !== 'false',
            perspective: localStorage.getItem('perspective') !== 'false',
            regionOcr: localStorage.getItem('regionOcr') !== 'false',
            quality: parseFloat(localStorage.getItem('quality')) || 0.7,
            threshold: parseInt(localStorage.getItem('threshold')) || 60,
            maxSize: 1000,
            aiCost: 0.002,
            region: { x: 0.05, y: 0.85, w: 0.4, h: 0.12 }
        };
        
        window.addEventListener('load', init);
        
        async function init() {
            console.log('üöÄ Initializing...');
            
            if (apiKey) {
                document.getElementById('apiKeyInput').value = apiKey;
                updateApiToggle(true);
            }
            
            await Promise.all([
                loadDatabase(),
                initTesseract(),
                loadOpenCV()
            ]);
            
            restoreSession();
            
            document.getElementById('uploadArea').onclick = () => document.getElementById('fileInput').click();
            document.getElementById('fileInput').onchange = handleFiles;
            
            console.log('‚úÖ Ready');
        }
        
        async function loadDatabase() {
            setStatus('db', 'loading');
            try {
                const res = await fetch('./card-database.json');
                if (!res.ok) throw new Error('DB not found');
                database = await res.json();
                ready.db = true;
                setStatus('db', 'ready');
                console.log(`‚úÖ DB: ${database.length} cards`);
            } catch (err) {
                console.error('‚ùå DB failed:', err);
                setStatus('db', 'error');
            }
        }
        
        function findCard(cardNumber) {
            if (!ready.db || !cardNumber) {
                console.error('findCard called but:', { dbReady: ready.db, cardNumber });
                return null;
            }
            
            const normalized = String(cardNumber).toUpperCase().trim();
            console.log('üîç Searching for card:', normalized);
            
            const match = database.find(c => {
                const dbNum = String(c['Card Number'] || '').toUpperCase().trim();
                return dbNum === normalized;
            });
            
            if (match) {
                console.log('‚úÖ Found match:', {
                    cardNumber: match['Card Number'],
                    name: match.Name,
                    set: match.Set
                });
            } else {
                console.log('‚ùå No exact match found');
                console.log('Sample DB entries:', database.slice(0, 3).map(c => ({
                    num: c['Card Number'],
                    name: c.Name
                })));
            }
            
            return match;
        }
        
        async function initTesseract() {
            setStatus('ocr', 'loading');
            try {
                while (typeof Tesseract === 'undefined') {
                    await new Promise(r => setTimeout(r, 100));
                }
                
                tesseractWorker = await Tesseract.createWorker('eng');
                ready.ocr = true;
                setStatus('ocr', 'ready');
                console.log('‚úÖ OCR ready');
            } catch (err) {
                console.error('‚ùå OCR failed:', err);
                setStatus('ocr', 'error');
            }
        }
        
        let cvLoadPromise = null;
        
        function loadOpenCV() {
            if (cvLoadPromise) return cvLoadPromise;
            
            setStatus('cv', 'loading');
            
            cvLoadPromise = new Promise((resolve) => {
                const script = document.createElement('script');
                script.src = 'https://docs.opencv.org/4.5.2/opencv.js';
                script.async = true;
                
                const timeout = setTimeout(() => {
                    console.warn('‚ö†Ô∏è OpenCV timeout');
                    setStatus('cv', 'error');
                    resolve(false);
                }, 8000);
                
                script.onload = () => {
                    const check = setInterval(() => {
                        if (typeof cv !== 'undefined' && cv.Mat) {
                            clearInterval(check);
                            clearTimeout(timeout);
                            ready.cv = true;
                            setStatus('cv', 'ready');
                            console.log('‚úÖ OpenCV ready');
                            resolve(true);
                        }
                    }, 100);
                };
                
                script.onerror = () => {
                    clearTimeout(timeout);
                    console.error('‚ùå OpenCV failed');
                    setStatus('cv', 'error');
                    resolve(false);
                };
                
                document.head.appendChild(script);
            });
            
            return cvLoadPromise;
        }
        
        function setStatus(type, state) {
            const el = document.getElementById(`status${type.charAt(0).toUpperCase() + type.slice(1)}`);
            el.className = `status-dot ${state}`;
        }
        
        function toggleApiSection() {
            const content = document.getElementById('apiContent');
            const icon = document.getElementById('apiToggleIcon');
            const expanded = content.classList.toggle('expanded');
            icon.textContent = expanded ? '‚ñ≤' : '‚ñº';
        }
        
        function updateApiToggle(hasKey) {
            const toggle = document.getElementById('apiToggle');
            const text = document.getElementById('apiToggleText');
            toggle.classList.toggle('has-key', hasKey);
            text.textContent = hasKey ? 'üîë API Key Saved' : 'üîë API Key';
        }
        
        function showToast(message, icon = '‚úì') {
            const toast = document.getElementById('toast');
            document.getElementById('toastIcon').textContent = icon;
            document.getElementById('toastMessage').textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }
        
        function showLoading(show, text = 'Processing...') {
            const overlay = document.getElementById('loadingOverlay');
            document.getElementById('loadingText').textContent = text;
            overlay.classList.toggle('active', show);
        }
        
        function setProgress(percent) {
            document.getElementById('progressFill').style.width = `${percent}%`;
        }
        
        function saveApiKey() {
            const input = document.getElementById('apiKeyInput');
            const key = input.value.trim();
            
            if (!key.startsWith('sk-ant-')) {
                showToast('Invalid key format', '‚ö†Ô∏è');
                return;
            }
            
            apiKey = key;
            localStorage.setItem('api_key', key);
            updateApiToggle(true);
            showToast('API key saved');
            toggleApiSection();
        }
        
        function clearApiKey() {
            if (!confirm('Clear API key?')) return;
            apiKey = '';
            localStorage.removeItem('api_key');
            document.getElementById('apiKeyInput').value = '';
            updateApiToggle(false);
            showToast('API key cleared');
        }
        
        function openSettings() {
            document.getElementById('settingsModal').classList.add('active');
            document.getElementById('toggleAutoDetect').checked = config.autoDetect;
            document.getElementById('togglePerspective').checked = config.perspective;
            document.getElementById('toggleRegionOcr').checked = config.regionOcr;
            document.getElementById('selectQuality').value = config.quality;
            document.getElementById('rangeThreshold').value = config.threshold;
            document.getElementById('thresholdValue').textContent = config.threshold;
        }
        
        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
        }
        
        function updateSetting(key, value) {
            config[key] = key === 'quality' ? parseFloat(value) : 
                         key === 'threshold' ? parseInt(value) : 
                         value;
            localStorage.setItem(key, value);
        }
        
        function resetSettings() {
            Object.keys(config).forEach(k => localStorage.removeItem(k));
            config.autoDetect = true;
            config.perspective = true;
            config.regionOcr = true;
            config.quality = 0.7;
            config.threshold = 60;
            openSettings();
            showToast('Settings reset');
        }
        
        window.addEventListener('beforeunload', () => {
            if (cards.length > 0) {
                localStorage.setItem('session', JSON.stringify({
                    cards: cards.map(c => ({ ...c, imageUrl: null })),
                    stats
                }));
            }
        });
        
        function restoreSession() {
            const saved = localStorage.getItem('session');
            if (!saved) return;
            
            if (confirm('Restore previous session?')) {
                const { cards: savedCards, stats: savedStats } = JSON.parse(saved);
                cards = savedCards;
                stats = savedStats;
                updateStats();
                renderCards();
            }
            localStorage.removeItem('session');
        }
        
        async function handleFiles(e) {
            const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/'));
            if (!files.length) return;
            
            if (files.length > 1) {
                if (!confirm(`Scan ${files.length} cards?`)) {
                    e.target.value = '';
                    return;
                }
            }
            
            for (let i = 0; i < files.length; i++) {
                showLoading(true, `Processing ${i + 1}/${files.length}...`);
                await processImage(files[i]);
                if (i < files.length - 1) await new Promise(r => setTimeout(r, 300));
            }
            
            e.target.value = '';
        }
        
        async function processImage(file) {
            try {
                const uploadArea = document.getElementById('uploadArea');
                uploadArea.classList.add('processing');
                
                setProgress(0);
                const imageUrl = URL.createObjectURL(file);
                setProgress(10);
                
                showLoading(true, 'Detecting card...');
                const processed = config.autoDetect ? await detectCard(imageUrl) : imageUrl;
                setProgress(30);
                
                showLoading(true, 'Reading card...');
                const { text, confidence } = await runOCR(processed);
                setProgress(60);
                
                const cardNumber = extractCardNumber(text);
                console.log({ text, confidence, cardNumber });
                
                if (!cardNumber || confidence < config.threshold) {
                    throw new Error('Low confidence');
                }
                
                showLoading(true, 'Looking up...');
                const match = findCard(cardNumber);
                setProgress(80);
                
                if (!match) throw new Error('Not in database');
                
                addCard(match, processed, file.name, 'free', confidence);
                setProgress(100);
                showToast(`Card ${cardNumber} scanned (FREE)`, 'üéâ');
                
            } catch (err) {
                console.log('OCR failed, trying AI:', err.message);
                
                if (!apiKey) {
                    showLoading(false);
                    showToast('OCR failed. Add API key?', '‚ö†Ô∏è');
                    return;
                }
                
                try {
                    showLoading(true, 'Using AI...');
                    const imageUrl = URL.createObjectURL(file);
                    const compressed = await compressImage(file);
                    setProgress(70);
                    
                    const data = await callAPI(compressed);
                    setProgress(85);
                    
                    // ‚úÖ VALIDATION 1: Check response structure
                    console.log('Full API response:', data);
                    
                    if (!data.content || !data.content[0] || !data.content[0].text) {
                        throw new Error('Empty or invalid response from AI');
                    }
                    
                    const rawText = data.content[0].text.replace(/```json|```/g, '').trim();
                    console.log('Claude raw text:', rawText);
                    
                    // ‚úÖ VALIDATION 2: Parse JSON
                    let parsed;
                    try {
                        parsed = JSON.parse(rawText);
                    } catch(e) {
                        throw new Error('Claude response not valid JSON: ' + rawText);
                    }
                    
                    // ‚úÖ VALIDATION 3: Check if cardNumber exists and is valid format
                    const cardNum = parsed.cardNumber;
                    
                    if (!cardNum) {
                        throw new Error('AI did not extract a card number');
                    }
                    
                    // Validate card number format (should be like "XX-###")
                    const cardNumPattern = /^[A-Z]{2,4}-\d{2,4}$/i;
                    if (!cardNumPattern.test(cardNum)) {
                        console.warn(`‚ö†Ô∏è Warning: Card number "${cardNum}" has unusual format`);
                    }
                    
                    console.log('‚úÖ Validated card number:', cardNum);
                    
                    // ‚úÖ VALIDATION 4: Try to find in database
                    const match = findCard(cardNum);
                    
                    if (!match) {
                        // Log nearby matches for debugging
                        const normalized = String(cardNum).toUpperCase().trim();
                        const similar = database
                            .filter(c => {
                                const dbNum = String(c['Card Number'] || '').toUpperCase().trim();
                                const prefix = normalized.split('-')[0];
                                const dbPrefix = dbNum.split('-')[0];
                                return dbNum.includes(prefix) || normalized.includes(dbPrefix);
                            })
                            .slice(0, 5)
                            .map(c => c['Card Number']);
                        
                        console.error('‚ùå Card not found in database');
                        console.log('Searched for:', normalized);
                        console.log('Similar cards in DB:', similar);
                        
                        throw new Error(`Card "${cardNum}" not found in database`);
                    }
                    
                    // ‚úÖ VALIDATION 5: Cross-validate with hero name if AI extracted it
                    if (parsed.hero) {
                        const aiHero = parsed.hero.toUpperCase().trim();
                        const dbHero = (match.Name || '').toUpperCase().trim();
                        
                        if (aiHero && dbHero && !dbHero.includes(aiHero) && !aiHero.includes(dbHero)) {
                            console.warn(`‚ö†Ô∏è Hero name mismatch: AI says "${parsed.hero}", DB says "${match.Name}"`);
                        } else {
                            console.log('‚úÖ Hero name validated:', match.Name);
                        }
                    }
                    
                    // ‚úÖ All validations passed - add the card
                    addCard(match, imageUrl, file.name, 'ai');
                    setProgress(100);
                    showToast(`Card ${cardNum} scanned (AI)`, 'üí∞');
                    stats.cost += config.aiCost;
                    
                } catch (aiErr) {
                    console.error('AI scan failed:', aiErr.message);
                    showToast('AI scan failed: ' + aiErr.message, '‚ùå');
                }
            } finally {
                showLoading(false);
                document.getElementById('uploadArea').classList.remove('processing');
                setProgress(0);
            }
        }
        
        async function detectCard(imageUrl) {
            if (!ready.cv || !config.autoDetect) return imageUrl;
            
            try {
                return await new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        try {
                            const canvas = document.createElement('canvas');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0);
                            
                            const src = cv.imread(canvas);
                            const gray = new cv.Mat();
                            const blurred = new cv.Mat();
                            const edges = new cv.Mat();
                            const contours = new cv.MatVector();
                            const hierarchy = new cv.Mat();
                            
                            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                            cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
                            cv.Canny(blurred, edges, 50, 150);
                            cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                            
                            let maxArea = 0;
                            let bestContour = null;
                            
                            for (let i = 0; i < contours.size(); i++) {
                                const contour = contours.get(i);
                                const area = cv.contourArea(contour);
                                const perimeter = cv.arcLength(contour, true);
                                const approx = new cv.Mat();
                                
                                cv.approxPolyDP(contour, approx, 0.02 * perimeter, true);
                                
                                if (approx.rows === 4 && area > maxArea) {
                                    maxArea = area;
                                    if (bestContour) bestContour.delete();
                                    bestContour = approx.clone();
                                }
                                
                                approx.delete();
                                contour.delete();
                            }
                            
                            let result = canvas.toDataURL('image/jpeg', config.quality);
                            
                            if (bestContour && config.perspective) {
                                result = applyPerspective(src, bestContour);
                            }
                            
                            src.delete();
                            gray.delete();
                            blurred.delete();
                            edges.delete();
                            contours.delete();
                            hierarchy.delete();
                            if (bestContour) bestContour.delete();
                            
                            resolve(result);
                        } catch (err) {
                            console.error('Detection error:', err);
                            resolve(imageUrl);
                        }
                    };
                    
                    img.onerror = () => resolve(imageUrl);
                    img.src = imageUrl;
                });
            } catch (error) {
                return imageUrl;
            }
        }
        
        function applyPerspective(src, contour) {
            try {
                const points = [];
                for (let i = 0; i < contour.rows; i++) {
                    points.push({
                        x: contour.data32S[i * 2],
                        y: contour.data32S[i * 2 + 1]
                    });
                }
                
                points.sort((a, b) => a.y - b.y);
                const top = points.slice(0, 2).sort((a, b) => a.x - b.x);
                const bottom = points.slice(2, 4).sort((a, b) => a.x - b.x);
                const ordered = [...top, ...bottom.reverse()];
                
                const cardWidth = 350;
                const cardHeight = 500;
                
                const srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
                    ordered[0].x, ordered[0].y,
                    ordered[1].x, ordered[1].y,
                    ordered[2].x, ordered[2].y,
                    ordered[3].x, ordered[3].y
                ]);
                
                const dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
                    0, 0,
                    cardWidth, 0,
                    cardWidth, cardHeight,
                    0, cardHeight
                ]);
                
                const M = cv.getPerspectiveTransform(srcPoints, dstPoints);
                const dst = new cv.Mat();
                const dsize = new cv.Size(cardWidth, cardHeight);
                
                cv.warpPerspective(src, dst, M, dsize);
                
                const canvas = document.createElement('canvas');
                cv.imshow(canvas, dst);
                const result = canvas.toDataURL('image/jpeg', config.quality);
                
                srcPoints.delete();
                dstPoints.delete();
                M.delete();
                dst.delete();
                
                return result;
            } catch (error) {
                console.error('Perspective error:', error);
                const canvas = document.createElement('canvas');
                cv.imshow(canvas, src);
                return canvas.toDataURL('image/jpeg', config.quality);
            }
        }
        
        async function runOCR(imageUrl) {
            if (!ready.ocr) throw new Error('OCR not ready');
            
            let targetImage = imageUrl;
            
            if (config.regionOcr) {
                targetImage = await extractRegion(imageUrl, config.region);
            }
            
            const result = await tesseractWorker.recognize(targetImage);
            return {
                text: result.data.text,
                confidence: result.data.confidence
            };
        }
        
        function extractRegion(imageUrl, region) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    const x = img.width * region.x;
                    const y = img.height * region.y;
                    const w = img.width * region.w;
                    const h = img.height * region.h;
                    
                    canvas.width = w;
                    canvas.height = h;
                    ctx.drawImage(img, x, y, w, h, 0, 0, w, h);
                    
                    const imageData = ctx.getImageData(0, 0, w, h);
                    const data = imageData.data;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = data[i] * 0.3 + data[i + 1] * 0.59 + data[i + 2] * 0.11;
                        const adjusted = gray > 128 ? 255 : 0;
                        data[i] = data[i + 1] = data[i + 2] = adjusted;
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    resolve(canvas.toDataURL('image/png'));
                };
                
                img.onerror = reject;
                img.src = imageUrl;
            });
        }
        
        function extractCardNumber(text) {
            const cleaned = text.replace(/[|]/g, 'I').replace(/[O]/g, '0').toUpperCase();
            
            const patterns = [
                /\b([A-Z]{2,4})[-‚Äì‚Äî]\s*(\d{2,4})\b/,
                /\b([A-Z]{2,4})\s+(\d{2,4})\b/,
                /\b([A-Z]{2,4})(\d{2,4})\b/
            ];
            
            for (const pattern of patterns) {
                const match = cleaned.match(pattern);
                if (match && match[1].length >= 2 && match[2].length >= 2) {
                    return `${match[1]}-${match[2]}`;
                }
            }
            
            const fallback = cleaned.match(/\b([A-Z]{2,})[^\w]*(\d{2,})\b/);
            return fallback ? `${fallback[1]}-${fallback[2]}` : null;
        }
        
        async function callAPI(imageData) {
            console.log('Calling API via Vercel backend...');
            
            const response = await fetch('https://boba-scanner.vercel.app/api/anthropic', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-haiku-4-5-20251001',
                    max_tokens: 500,
                    messages: [{
                        role: 'user',
                        content: [
                            {
                                type: 'image',
                                source: {
                                    type: 'base64',
                                    media_type: 'image/jpeg',
                                    data: imageData
                                }
                            },
                            {
                                type: 'text',
                                text: `Extract card information:
1. Card number from bottom left (format: XX-###)
2. Hero name from top of card

Return ONLY this JSON:
{
  "cardNumber": "XX-###",
  "hero": "Hero Name"
}`
                            }
                        ]
                    }]
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `API failed: ${response.status}`);
            }
            
            return await response.json();
        }
        
        async function compressImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;
                        
                        if (width > config.maxSize || height > config.maxSize) {
                            if (width > height) {
                                height = (height / width) * config.maxSize;
                                width = config.maxSize;
                            } else {
                                width = (width / height) * config.maxSize;
                                height = config.maxSize;
                            }
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve(canvas.toDataURL('image/jpeg', config.quality).split(',')[1]);
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        function addCard(match, imageUrl, fileName, type, confidence = null) {
            const card = {
                cardId: match['Card ID'] || '',
                hero: match.Name || '',
                year: match.Year || '',
                set: match.Set || '',
                cardNumber: match['Card Number'] || '',
                pose: match.Parallel || '',
                weapon: match.Weapon || '',
                power: match.Power || '',
                imageUrl,
                fileName,
                scanType: type,
                scanMethod: type === 'free' ? `Free OCR (${Math.round(confidence)}%)` : 'AI + Database'
            };
            
            cards.push(card);
            stats.scanned++;
            if (type === 'free') stats.free++;
            
            updateStats();
            renderCards();
            
            if (navigator.vibrate) {
                navigator.vibrate(type === 'free' ? 50 : [50, 100, 50]);
            }
        }
        
        function removeCard(index) {
            if (cards[index].imageUrl) {
                URL.revokeObjectURL(cards[index].imageUrl);
            }
            cards.splice(index, 1);
            stats.scanned--;
            updateStats();
            renderCards();
        }
        
        function clearAll() {
            if (!confirm('Clear all cards?')) return;
            cards.forEach(c => c.imageUrl && URL.revokeObjectURL(c.imageUrl));
            cards = [];
            stats = { scanned: 0, free: 0, cost: 0 };
            updateStats();
            renderCards();
            showToast('All cards cleared');
        }
        
        function updateStats() {
            const paid = stats.scanned - stats.free;
            const rate = stats.scanned > 0 ? Math.round((stats.free / stats.scanned) * 100) : 0;
            
            document.getElementById('statFree').textContent = stats.free;
            document.getElementById('statPaid').textContent = paid;
            document.getElementById('statCost').textContent = `$${stats.cost.toFixed(2)}`;
            document.getElementById('statRate').textContent = `${rate}%`;
            
            document.getElementById('statsBar').classList.toggle('hidden', stats.scanned === 0);
        }
        
        function renderCards() {
            const grid = document.getElementById('cardsGrid');
            const empty = document.getElementById('emptyState');
            const actionBar = document.getElementById('actionBar');
            
            if (cards.length === 0) {
                empty.classList.remove('hidden');
                actionBar.classList.add('hidden');
                grid.innerHTML = '';
                return;
            }
            
            empty.classList.add('hidden');
            actionBar.classList.remove('hidden');
            document.getElementById('exportCount').textContent = cards.length;
            
            grid.innerHTML = cards.map((card, i) => `
                <div class="card">
                    <img class="card-image" src="${card.imageUrl}" alt="${card.cardNumber}">
                    <div class="card-body">
                        <span class="card-badge ${card.scanType === 'free' ? 'badge-free' : 'badge-paid'}">
                            ${card.scanMethod}
                        </span>
                        <div class="card-fields">
                            ${renderField('Card ID', 'cardId', i, card.cardId, true)}
                            ${renderField('Name', 'hero', i, card.hero, true)}
                            ${renderField('Year', 'year', i, card.year, true)}
                            ${renderField('Set', 'set', i, card.set, true)}
                            ${renderField('Card #', 'cardNumber', i, card.cardNumber, false)}
                            ${renderField('Parallel', 'pose', i, card.pose, true)}
                            ${renderField('Weapon', 'weapon', i, card.weapon, true)}
                            ${renderField('Power', 'power', i, card.power, true)}
                        </div>
                        <button class="btn-remove" onclick="removeCard(${i})">Remove</button>
                    </div>
                </div>
            `).join('');
        }
        
        function renderField(label, field, index, value, autoFilled) {
            return `
                <div class="field">
                    <div class="field-label">${label}</div>
                    <input class="field-input ${autoFilled ? 'auto-filled' : ''}" 
                           value="${value}" 
                           onchange="updateCard(${index}, '${field}', this.value)">
                </div>
            `;
        }
        
        function updateCard(index, field, value) {
            cards[index][field] = value;
        }
        
        function exportCSV() {
            if (cards.length === 0) return;
            
            const headers = ['Card ID', 'Name', 'Year', 'Set', 'Card Number', 'Parallel', 'Weapon', 'Power', 'Scan Method'];
            const rows = cards.map(c => [
                c.cardId, c.hero, c.year, c.set, c.cardNumber, c.pose, c.weapon, c.power, c.scanMethod
            ]);
            
            const csv = [
                headers.join(','),
                ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
            ].join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cards_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);
            
            showToast(`Exported ${cards.length} cards`);
        }
    </script>
</body>
</html>
